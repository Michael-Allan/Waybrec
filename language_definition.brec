Waybrec language definition

    - Waybrec is an extension of Breccia.
    - This file defines the extensions.
        : see also `Novel types introduced` @ `^^ Fractal types$`
    - Novel fractal types introduced by Waybrec:
        : re `fractal types` see also @ http://reluk.ca/project/Breccia/language_definition.brec

        ╷ command point
        ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            ◆ body reference
            ◇ patch
                ◆ switch patch
                ◆ insertion patch
                ◆ substitution patch
            ◆ thoroughfractum designator

            : see `^^legend$` @ `fractal types` @ http://reluk.ca/project/Breccia/language_definition.brec



    ━━━━━━━━━━━━━━━━━━━━━━━
     Associative reference
    ───────────────────────
        : see also @ http://reluk.ca/project/Breccia/language_definition.brec
        - No associative reference may refer to a patch or patch constituent.
            : cf. `^^- No patch nor descendant of a patch is considered to be on-way` @ `^^ Patch$`
            / Either one must refer to where the patch is applied, or use a `non-fractal` qualifier.
        compile( associative reference )
            : join `^^simulacral reference$` @ `^^ Notes$`
            + `referrers( associative reference )`
                : re `\`(.+)\`` see same head @ http://reluk.ca/project/Breccia/language_definition.brec
            deem+ `t` the referent
            + Set `t` to `referent( associative reference )`.
                : re `referent\(.+\)` see same head @
                  http://reluk.ca/project/Breccia/language_definition.brec
            if( `t` is a patch, or lies within a patch )
                throw+ invalid referent: patch or patch constituent



    ━━━━━━━━━━━━━━━━
     Body reference
    ────────────────
        - A command point that refers to the body of a fractum.
        - Its command has this form:

              ╶──╴‘body’╶── P ── containment clause ───▶

        - The referent of a body reference `rB` is the body of `referent parent( rB )`.
        / The determination is recursive, as the formal referent may itself be a body reference.

        referent parent( body reference `rB` )
            : join `^^simulacral reference$` @ `^^ Note$`
            deem+ `p` a fractum
            + Set `p` to `indicated fractum( fractum indicant of containment clause of rB )`
            if( the body of `p` comprises a body reference `rrB` )
                return+ `referent parent( rrB )`
                    / Here compilers should detect and avoid any infinite reference loop.
            + `warn of ignored body references( p )`
            return+ `p`

        warn of ignored body references( fractum `f`, whose body comprises other than a body reference )
            : join `^^simulacral reference$` @ `^^ Note$`
            for( each child of `f` that is a body reference )
                + Warn ‘Body reference ignored: it is not the sole child.’



    ━━━━━━━━━
     Jointer
    ─────────
        : see also @ http://reluk.ca/project/Breccia/language_definition.brec
        - With a fractal referent, a jointer brings the referent on-way.
            : re `fractal referent` cf. `^^non-fractal$` @
              http://reluk.ca/project/wayic/refractory/index.brec
            - Thereby it brings the referent file or waycast into the way model, if not there already.
            / A pointer has no such effect.
            - A waycaster may substitute a jointer for a pointer wherever he wants this effect.
                / E.g. for purposes of patching.
        compile( jointer )
            + `compile( jointer )`
                : re `\`(.+)\`` see same head @ `^^ Jointer$` @
                  http://reluk.ca/project/Breccia/language_definition.brec
            deem+ `sub` the fractum thereby subjoined
            - Each child of `sub` gains for a parent each parent of the jointer
              that does not duplicate a pre-existing parent.
                : cf. `Each parent of the jointer gains for a child` @ `^^ Jointer$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



    ━━━━━━━
     Patch
    ───────
        - A command point that alters the way model.
        - Its command has this form:

                                   directive
                                ┌──────────────┐
             
                                 ┌───╴‘on’╶───┐
                                 │            │
                                 ├───╴‘off’╶──┤        remote fractum
              ╶──╴‘patch’╶── S ──┤            ├── P ──╴   indicant   ╶───▶
                                 ├─╴‘before’╶─┤
                                 │            │
                                 ├──╴‘after’╶─┤
                                 │            │
                                 └──╴‘over’╶──┘

                : re `(fractum)\R.*(indicant)` see `^^ Fractum indicant$` @
                  http://reluk.ca/project/Breccia/language_definition.brec
        - No patch may descend, whether directly or by body reference, from a patch.
        - No patch nor descendant of a patch is considered to be on-way.
            : see `^^- Patch bodies as such are not compiled` @ `^^ Patch$`
        - The directive of a patch determines its type as one of switch, insertion or substitution.

              Directive      Patch type
             ╶───────────────────────────
              on, off        switch
              before, after  insertion
              over           substitution

        - The remote fractum indicant of a patch indicates its application target.
            : re `application` see `^^apply\( patch \)$`
            - It must not contain a `non-fractal` qualifier.
            - The indicated target must lie in a waycast remote from that in which the patch is declared.
                - The canonical locations of the two waycasts must differ.
            - Patches whose targets fall within the way model alone are applied.
        - The target of a switch patch is an insertion or substitution patch to be switched on or off.
            - All switch patches are bodiless.
        - The body of an insertion or substitution patch defines, either directly or by body reference,
          the content to be inserted or substituted into the way model at the target.
            / For this purpose a body reference may be used, e.g. referring to the body of another patch,
              in order to (re)apply the same content to a different target.
            - Any relative paths within a patch body are converted to URI form during application.
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
            - Patch bodies as such are not compiled; rather the patches are applied to the way model,
              then the patched way model is compiled.
            - A bodiless substitution patch effects a deletion.

        apply( insertion or substitution patch `p`, subsumed file path `f` )
            : join `^^simulacral reference$` @ `^^ Note$`
            : see also `^^ Patch application$` @
              http://reluk.ca/project/wayic/model/form_and_compilation.brec
            / The caller must ensure that `f` originates in a waycast whose canonical location
              differs from that in which the patch was declared.
            deem+ `d` a directive, that of `p`;
                  `iF` a fractum indicant, equal in content to the remote fractum indicant of `p`;
                  `t` a target
            + Set the resource indicant of `iF` to `f`.
            + Set `t` to `indicated fractum( iF )`.
                : see `^^indicated fractum\( fractum indicant` @ `^^ Fractum indicant$` @
                  http://reluk.ca/project/Breccia/language_definition.brec
            if( `t` is a patch descendant )
                throw+ Attempt to patch a patch
                    / One may patch the application of a patch, but not the patch itself.
            deem+ `fB` a fractum, that which contains the applicable body of the patch
            if( the body of `p` comprises a body reference `rB` )
                + Set `fB` to `referent parent( rB )`.
            else
                + Set `fB` to `p`.
                + `warn of ignored body references( fB )`
            switch( `d` )
                case( ‘before’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in linear order )
                        + Insert in the model as the sibling predecessor of `t` a copy of `c`,
                          and convert to URI form any relative paths it contains.
                            : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
                case( ‘after’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in reverse linear order )
                        + Insert in the model as the sibling successor of `t` a copy of `c`,
                          and convert to URI form any relative paths it contains.
                            : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
                case( ‘over’ )
                    if( `t` is a patch )
                        throw+ Attempt to patch a patch
                    if( `t` is a file fractum and `fB` has multiple children )
                        throw+ Attempt to introduce sibling file fracta
                    if( `fB` has a body )
                        for( each child `c` of `fB` in linear order )
                            + Insert in the model as the sibling predecessor of `t` a copy of `c`,
                              and convert to URI form any relative paths it contains.
                                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
                    + Delete from the model `t`.



    ━━━━━━━━━━━━━━━━━━━
     Resource indicant
    ───────────────────
        : see also @ http://reluk.ca/project/Breccia/language_definition.brec
                ·
                    ┌──────────╴◀──────────────────┐
                    │                              │
                    │  ┌──╴‘non-fractal’╶──┐       │
              ╶──┬──┴──┤                   ├── P ──┴──┬── URI reference ────▶
                 │     └───╴‘uninterned’╶──┘          │
                 │                                    │
                 └────────────────────────────────────┘
                    : re `URI reference` see https://tools.ietf.org/html/rfc3986#section-4.1
                diagram, The form of a resource indicant.

            / Here Waybrec introduces the `uninterned` qualifier.
        - The `uninterned` qualifier, where present on a resource indicant of an associative reference,
          stops any internment of the reference, and any subsumption that otherwise would have
          occured on account of the reference.
            - Outside of an associative reference, the `uninterned` qualifier has no effect.



    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     Thoroughfractum designator
    ────────────────────────────
        / A type of command point.
        - It marks its simulacral parent as a thoroughfractum, thereby defining the surjoint apex
          from which the way model depends.
        - Its command has this form:

              ╶──╴‘thoroughfractum’╶───▶



    ━━━━━━━━━━━━━━━━━━━━━━
     Way engagement point
    ──────────────────────
        - A task point made private by an intracast privatizer.
            / The task point itself is either intracast, or extracast by way of a jointer.
        - It declares a way engagement.



    ━━━━━━
     Note
    ──────
        simulacral reference
            - Herein the default referent is the simulacrum (aka the way model), not the source code.
                : cf. `^^default referent` @ `^^ Simulacrum$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



                                                    \ Copyright © 2019-2021  Michael Allan.  Licence MIT.
