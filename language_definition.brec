Waybrec language definition

    - Waybrec is an extension of Breccia.
    - This file defines the extensions.
        : see also `Novel types introduced` @ `^^ Fractal types$`
    - Novel fractal types introduced by Waybrec:
        : re `fractal types` see @ http://reluk.ca/project/Breccia/language_definition.brec

        ╷ command point
        ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            ◆ body reference
            ◇ patch
                ◆ switch patch
                ◆ insertion patch
                ◆ substitution patch
            ◆ thoroughfractum designator

            : see `^^legend$` @ `fractal types` @ http://reluk.ca/project/Breccia/language_definition.brec



    ━━━━━━━━━━━━━━━━
     Body reference
    ────────────────
        - A command point that refers to the body of a fractum.
        - Its command has this form:

              ╶──╴‘body’╶── P ── containment clause ───▶

        - Its referent is the body of `indicated fractum( fractum indicant of containment clause )`.


    ━━━━━━━━━
     Jointer
    ─────────
        : see @ http://reluk.ca/project/Breccia/language_definition.brec
        - With a fractal referent, a jointer brings the referent on-way.
            : re `fractal referent` see `The `non-fractal` qualifier` @ `^^ Resource indicant$` @
              http://reluk.ca/project/Breccia/language_definition.brec
            - Thereby it brings the referent file or waycast into the way model, if not there already.
            / A pointer has no such effect.
            - A waycaster may substitute a jointer for a pointer wherever he wants this effect.
                / E.g. for purposes of patching.
        - No jointer may refer to a patch or patch descendant.
            : see `^^- No patch nor descendant of a patch is considered to be on-way.$` @ `^^ Patch$`



    ━━━━━━━
     Patch
    ───────
        - A command point that alters the way model.
        - Its command has this form:

                                   directive
                                 ┌────────────┐
             
                                 ┌───╴‘on’╶───┐
                                 │            │
                                 ├───╴‘off’╶──┤
              ╶──╴‘patch’╶── S ──┤            ├── P ── fractum indicant ───▶
                                 ├─╴‘before’╶─┤
                                 │            │
                                 ├──╴‘after’╶─┤
                                 │            │
                                 └──╴‘over’╶──┘

        - No patch may descend, whether directly or by body reference, from a patch.
        - No patch nor descendant of a patch is considered to be on-way.
            : see `^^- Patch bodies as such are not compiled` @ `^^ Patch$`
        - The directive of a patch determines its type as one of switch, insertion or substitution.

              Directive      Patch type
             ╶───────────────────────────
              on, off        switch
              before, after  insertion
              over           substitution

        - The fractum indicant of a patch indicates its application target.
            : re `application` see `^^apply\( patch \)$`
            - Targets within files of the way model alone are valid.
                / The intent of this rule is to avoid an accumulation of pointless, obsolete patches.
        - The target of a switch patch is an insertion or substitution patch to be switched on or off.
            - The targeted patch must be declared within a waycast of the way model (a waycast with at
              least one file in the model) and its own target must lie within a file of the way model.
            - All switch patches are bodiless.
        - The body of an insertion or substitution patch defines, either directly or by body reference,
          the content to be inserted or substituted into the way model at the target.
            - Patch bodies as such are not compiled; rather the patches are applied to the way model,
              then the way model is compiled.
            - A bodiless substitution patch effects a deletion.

        apply( insertion or substitution patch `p` )
            : join `^^simulacral reference$` @ `^^ Notes$` @
              http://reluk.ca/project/Breccia/language_definition.brec
            deem+ `d` a directive, that of `p`;
                  `iF` a fractum indicant, that of `p`;
                  `t` a target, that of `indicated fractum( iF )`
            if( `t` is a patch descendant )
                throw+ Attempt to patch a patch
                    / One may patch the application of a patch, but not the patch itself.
            deem+ `fB` a fractum, that which contains the applicable body of the patch
            if( the body of `p` comprises a body reference `rB` )
                + Set `fB` to `indicated fractum( fractum indicant of `rB` )`.
            else
                for( each descendant of `p` that is a body reference )
                    warn+ Body reference ignored because it is not the sole child of the patch
                + Set `fB` to `p`.
            switch( `d` )
                case( ‘before’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in linear order )
                        + Insert a copy of `c` as the sibling predecessor of `t`.
                case( ‘after’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in reverse linear order )
                        + Insert a copy of `c` as the sibling successor of `t`.
                case( ‘over’ )
                    if( `t` is a patch )
                        throw+ Attempt to patch a patch
                    if( `t` is a file fractum and `fB` has multiple children )
                        throw+ Attempt to introduce sibling file fracta
                    if( `fB` has a body )
                        for( each child `c` of `fB` in linear order )
                            + Insert a copy of `c` as the sibling predecessor of `t`.
                    + Delete `t`.



    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     Thoroughfractum designator
    ────────────────────────────
        / A type of command point.
        - It marks its simulacral parent as a thoroughfractum, thereby defining the surjoint apex
          from which the way model depends.
        - Its command has this form:

              ╶──╴‘thoroughfractum’╶───▶



    ━━━━━━━━━━━━━━━━━━━━━━
     Way engagement point
    ──────────────────────
        - A task point made private by an intracast privatizer.
            / The task point itself is either intracast, or extracast by way of a jointer.
        - It declares a way engagement.



    ━━━━━━━━━━━
     Way model
    ───────────
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - The Waybreccian text of a waycast in compiled, executable form,
          as opposed to the initial, written form of its source code.
            - A representation of an aimed way of life.
            - A Waybreccian simulacrum.
        - It comprises a compiled set of Breccian files, each of which either belongs to the waycast
          or lies subjoint of it.
        - It results from compiling the waycast.



                                                    \ Copyright © 2019-2021  Michael Allan.  Licence MIT.
