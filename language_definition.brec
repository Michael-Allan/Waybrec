Waybrec language definition

    - Waybrec is an extension of Breccia.
    - This file defines the extensions.
        : see also `Novel types introduced` @ `^^ Fractal types$`
    - Novel fractal types introduced by Waybrec:
        : re `fractal types` see @ http://reluk.ca/project/Breccia/language_definition.brec

        ╷ command point
        ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            ◆ body reference
            ◇ patch
                ◆ switch patch
                ◆ insertion patch
                ◆ substitution patch
            ◆ thoroughfractum designator

            : see `^^legend$` @ `fractal types` @ http://reluk.ca/project/Breccia/language_definition.brec



    ━━━━━━━━━━━━━━━━
     Body reference
    ────────────────
        - A command point that refers to the body of a fractum.
        - Its command has this form:

              ╶──╴‘body’╶── P ── containment clause ───▶

        - The referent of a body reference `rB` is the body of `referent parent( rB )`.
        / The determination is recursive, as the formal referent may itself be a body reference.

        referent parent( body reference `rB` )
            : join `^^simulacral reference$` @ `^^ Note$`
            deem+ `p` a fractum
            + Set `p` to `indicated fractum( fractum indicant of containment clause of rB )`
            if( the body of `p` comprises a body reference `rrB` )
                return+ `referent parent( rrB )`
                    / Here compilers should detect and avoid an infinite reference loop.
            warn of ignored body references(+ `p` )
            return+ `p`

        warn of ignored body references( fractum `f`, whose body comprises other than a body reference )
            : join `^^simulacral reference$` @ `^^ Note$`
            for( each child of `f` that is a body reference )
                warn+ Body reference ignored: it is not the sole child



    ━━━━━━━━━
     Jointer
    ─────────
        : see @ http://reluk.ca/project/Breccia/language_definition.brec
        - With a fractal referent, a jointer brings the referent on-way.
            : re `fractal referent` see `The `non-fractal` qualifier` @ `^^ Resource indicant$` @
              http://reluk.ca/project/Breccia/language_definition.brec
            - Thereby it brings the referent file or waycast into the way model, if not there already.
            / A pointer has no such effect.
            - A waycaster may substitute a jointer for a pointer wherever he wants this effect.
                / E.g. for purposes of patching.
        - No jointer may refer to a patch or patch descendant.
            : see `^^- No patch nor descendant of a patch is considered to be on-way.$` @ `^^ Patch$`
        compile( jointer )
            compile(+ jointer )
                : join @ `^^ Jointer$` @ http://reluk.ca/project/Breccia/language_definition.brec
            deem+ `sub` the fractum thereby subjoined
            - Each child of `sub` gains for a parent each parent of the jointer
              that does not duplicate a pre-existing parent.
                : cf. `Each parent of the jointer gains for a child` @ `^^ Jointer$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



    ━━━━━━━
     Patch
    ───────
        - A command point that alters the way model.
        - Its command has this form:

                                   directive
                                 ┌────────────┐
             
                                 ┌───╴‘on’╶───┐
                                 │            │
                                 ├───╴‘off’╶──┤
              ╶──╴‘patch’╶── S ──┤            ├── P ── fractum indicant ───▶
                                 ├─╴‘before’╶─┤
                                 │            │
                                 ├──╴‘after’╶─┤
                                 │            │
                                 └──╴‘over’╶──┘

        - No patch may descend, whether directly or by body reference, from a patch.
        - No patch nor descendant of a patch is considered to be on-way.
            : see `^^- Patch bodies as such are not compiled` @ `^^ Patch$`
        - The directive of a patch determines its type as one of switch, insertion or substitution.

              Directive      Patch type
             ╶───────────────────────────
              on, off        switch
              before, after  insertion
              over           substitution

        - The fractum indicant of a patch indicates its application target.
            : re `application` see `^^apply\( patch \)$`
            - Targets within files of the way model alone are valid.
                / The intent of this rule is to avoid an accumulation of pointless, obsolete patches.
        - The target of a switch patch is an insertion or substitution patch to be switched on or off.
            - The targeted patch must be declared within a waycast of the way model (a waycast with at
              least one file in the model) and its own target must lie within a file of the way model.
            - All switch patches are bodiless.
        - The body of an insertion or substitution patch defines, either directly or by body reference,
          the content to be inserted or substituted into the way model at the target.
            / For this purpose a body reference may be used, e.g. referring to the body of another patch,
              in order to (re)apply the same content to a different target.
            - URI references within a patch body are formed as usual, and rebased to the target file
              (or files) only at time of application.
            - Patch bodies as such are not compiled; rather the patches are applied to the way model,
              then the patched way model is compiled.
            - A bodiless substitution patch effects a deletion.

        apply( insertion or substitution patch `p` )
            : join `^^simulacral reference$` @ `^^ Note$`
            deem+ `d` a directive, that of `p`;
                  `iF` a fractum indicant, that of `p`;
                  `t` a target, that of `indicated fractum( iF )`
            if( `t` is a patch descendant )
                throw+ Attempt to patch a patch
                    / One may patch the application of a patch, but not the patch itself.
            deem+ `fB` a fractum, that which contains the applicable body of the patch
            if( the body of `p` comprises a body reference `rB` )
                + Set `fB` to `referent parent( rB )`.
            else
                + Set `fB` to `p`.
                warn of ignored body references(+ `fB` )
            switch( `d` )
                case( ‘before’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in linear order )
                        + Insert as the sibling predecessor of `t` a copy of `c`,
                          and rebase accordingly any URI references it contains.
                case( ‘after’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in reverse linear order )
                        + Insert as the sibling successor of `t` a copy of `c`,
                          and rebase accordingly any URI references it contains.
                case( ‘over’ )
                    if( `t` is a patch )
                        throw+ Attempt to patch a patch
                    if( `t` is a file fractum and `fB` has multiple children )
                        throw+ Attempt to introduce sibling file fracta
                    if( `fB` has a body )
                        for( each child `c` of `fB` in linear order )
                            + Insert as the sibling predecessor of `t` a copy of `c`,
                              and rebase accordingly any URI references it contains.
                    + Delete `t`.



    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     Thoroughfractum designator
    ────────────────────────────
        / A type of command point.
        - It marks its simulacral parent as a thoroughfractum, thereby defining the surjoint apex
          from which the way model depends.
        - Its command has this form:

              ╶──╴‘thoroughfractum’╶───▶



    ━━━━━━━━━━━━━━━━━━━━━━
     Way engagement point
    ──────────────────────
        - A task point made private by an intracast privatizer.
            / The task point itself is either intracast, or extracast by way of a jointer.
        - It declares a way engagement.



    ━━━━━━
     Note
    ──────
        simulacral reference
            - Herein the default referent is the simulacrum (aka the way model), not the source code.
                : cf. `^^default referent` @ `^^ Simulacrum$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



                                                    \ Copyright © 2019-2021  Michael Allan.  Licence MIT.
