Waybrec language definition

    - Waybrec is an extension of Breccia.
    - This file defines the extensions.
        : see also `Novel types introduced` @ `^^ Fractal types$`
    - Novel fractal types introduced by Waybrec:
        : re `fractal types` see @ http://reluk.ca/project/Breccia/language_definition.brec

        ╷ command point
        ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            ◆ body reference
            ◇ patch
                ◆ switch patch
                ◆ insertion patch
                ◆ substitution patch
            ◆ thoroughfractum designator

            : see `^^legend$` @ `fractal types` @ http://reluk.ca/project/Breccia/language_definition.brec



    ━━━━━━━━━━━━━━━━
     Body reference
    ────────────────
        - A command point that refers to the body of a fractum.
        - Its command has this form:

              ╶──╴‘body’╶── P ── containment clause ───▶

        - The referent of a body reference `rB` is the body of `referent parent( rB )`.
        / The determination is recursive, as the formal referent may itself be a body reference.

        referent parent( body reference `rB` )
            : join `^^simulacral reference$` @ `^^ Note$`
            deem+ `p` a fractum
            + Set `p` to `indicated fractum( fractum indicant of containment clause of rB )`
            if( the body of `p` comprises a body reference `rrB` )
                return+ `referent parent( rrB )`
                    / Here compilers should detect and avoid an infinite reference loop.
            warn of ignored body references(+ `p` )
            return+ `p`

        warn of ignored body references( fractum `f`, whose body comprises other than a body reference )
            : join `^^simulacral reference$` @ `^^ Note$`
            for( each child of `f` that is a body reference )
                warn+ Body reference ignored: it is not the sole child



    ━━━━━━━━━━━━━
     Compilation
    ─────────────
        : cf. @ http://reluk.ca/project/Breccia/language_definition.brec
        - Compilation of a way model from a waycast.
        compile( waycast `w` )
            : join `^^simulacral reference$` @ `^^ Note$`
            0+ Initialize
                if( `w` contains at its base a file or directory named `:` )
                    throw+ Disallowed file name
            1+ Intern
            2+ Patch
            3+ Compile



    ━━━━━━━━━━━━
     Internment
    ────────────
        - All extracast files of a way model are copied and stored (interned) within the model
          at a path formed as follows.

              ╶──╴‘:/’╶── authority ── path ───▶

                : re `authority` see https://tools.ietf.org/html/rfc3986#section-3.2
                : re `path` see https://tools.ietf.org/html/rfc3986#section-3.3
            - The authority and path components of the interned file
              are those of its original location (URI form).
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
        - A public way model includes its internments, to which other waysource may refer.
            / The following, for example, refers to a publicly interned file.
              http://reluk.ca/project/waycast/:/cleo.abacus.au/walt/waycast/foo.brec
            - The referent, in that case, would be the file as seen in the interning way model (M).
                / E.g. `https://cleo.abacus.au/walt/waycast/foo.brec`
                  as seen in `http://reluk.ca/project/waycast/`.
            - Compiling a jointer to such a referent would intern the file from its original waycast,
              while applying (where conflict resolution allows) the patches of M.

        intern( URI `u` )
            / Interns the referent of the given URI, unless already it was interned.
            if( `u` lacks an authority component )
                throw+ Malformed reference
            if( `u` refers to a waycast file )
                + Set `u` to `canonicalize( u )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
                deem+ `uL` a URI, that of the canonical location of the local waycast
                if( `u` begins with `uL` )
                    throw+ Attempt to intern a local waycast file
            deem+ `p` the internment path derived from `u`
                : re `internment path` see `are .+interned.+ at a path formed as follows`
            if( `p` is  absent from the way model )
                + Copy the referent of `u` to `p`.
                for( each relative reference `r` in the copy )
                    + Replace `r` with an absolute reference, that of `r` resolved against `u`.



    ━━━━━━━━━
     Jointer
    ─────────
        : see @ http://reluk.ca/project/Breccia/language_definition.brec
        - With a fractal referent, a jointer brings the referent on-way.
            : re `fractal referent` see `The `non-fractal` qualifier` @ `^^ Resource indicant$` @
              http://reluk.ca/project/Breccia/language_definition.brec
            - Thereby it brings the referent file or waycast into the way model, if not there already.
            / A pointer has no such effect.
            - A waycaster may substitute a jointer for a pointer wherever he wants this effect.
                / E.g. for purposes of patching.
        - No jointer may refer to a patch or patch descendant.
            : see `^^- No patch nor descendant of a patch is considered to be on-way.$` @ `^^ Patch$`
        compile( jointer )
            compile(+ jointer )
                : join @ `^^ Jointer$` @ http://reluk.ca/project/Breccia/language_definition.brec
            deem+ `sub` the fractum thereby subjoined
            - Each child of `sub` gains for a parent each parent of the jointer
              that does not duplicate a pre-existing parent.
                : cf. `Each parent of the jointer gains for a child` @ `^^ Jointer$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



    ━━━━━━━
     Patch
    ───────
        - A command point that alters the way model.
        - Its command has this form:

                                   directive
                                 ┌────────────┐
             
                                 ┌───╴‘on’╶───┐
                                 │            │
                                 ├───╴‘off’╶──┤
              ╶──╴‘patch’╶── S ──┤            ├── P ── fractum indicant ───▶
                                 ├─╴‘before’╶─┤
                                 │            │
                                 ├──╴‘after’╶─┤
                                 │            │
                                 └──╴‘over’╶──┘

        - No patch may descend, whether directly or by body reference, from a patch.
        - No patch nor descendant of a patch is considered to be on-way.
            : see `^^- Patch bodies as such are not compiled` @ `^^ Patch$`
        - The directive of a patch determines its type as one of switch, insertion or substitution.

              Directive      Patch type
             ╶───────────────────────────
              on, off        switch
              before, after  insertion
              over           substitution

        - The fractum indicant of a patch indicates its application target.
            : re `application` see `^^apply\( patch \)$`
            - Targets within files of the way model alone are valid.
                / The intent of this rule is to avoid an accumulation of pointless, obsolete patches.
        - The target of a switch patch is an insertion or substitution patch to be switched on or off.
            - The targeted patch must be declared within a waycast of the way model (a waycast with at
              least one file in the model) and its own target must lie within a file of the way model.
            - All switch patches are bodiless.
        - The body of an insertion or substitution patch defines, either directly or by body reference,
          the content to be inserted or substituted into the way model at the target.
            / For this purpose a body reference may be used, e.g. referring to the body of another patch,
              in order to re-apply the same patch content to a different target.
            - Patch bodies as such are not compiled; rather the patches are applied to the way model,
              then the way model is compiled.
            - A bodiless substitution patch effects a deletion.

        apply( insertion or substitution patch `p` )
            : join `^^simulacral reference$` @ `^^ Note$`
            deem+ `d` a directive, that of `p`;
                  `iF` a fractum indicant, that of `p`;
                  `t` a target, that of `indicated fractum( iF )`
            if( `t` is a patch descendant )
                throw+ Attempt to patch a patch
                    / One may patch the application of a patch, but not the patch itself.
            deem+ `fB` a fractum, that which contains the applicable body of the patch
            if( the body of `p` comprises a body reference `rB` )
                + Set `fB` to `referent parent( rB )`.
            else
                + Set `fB` to `p`.
                warn of ignored body references(+ `fB` )
            switch( `d` )
                case( ‘before’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in linear order )
                        + Insert a copy of `c` as the sibling predecessor of `t`.
                case( ‘after’ )
                    if( `fB` is bodiless )
                        throw+ Bodiless insertion patch
                    if( `t` is a file fractum )
                        throw+ Attempt to introduce a sibling to a file fractum
                    for( each child `c` of `fB` in reverse linear order )
                        + Insert a copy of `c` as the sibling successor of `t`.
                case( ‘over’ )
                    if( `t` is a patch )
                        throw+ Attempt to patch a patch
                    if( `t` is a file fractum and `fB` has multiple children )
                        throw+ Attempt to introduce sibling file fracta
                    if( `fB` has a body )
                        for( each child `c` of `fB` in linear order )
                            + Insert a copy of `c` as the sibling predecessor of `t`.
                    + Delete `t`.



    ━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     Thoroughfractum designator
    ────────────────────────────
        / A type of command point.
        - It marks its simulacral parent as a thoroughfractum, thereby defining the surjoint apex
          from which the way model depends.
        - Its command has this form:

              ╶──╴‘thoroughfractum’╶───▶



    ━━━━━━━━━━━━━━━━━━━━━━
     Way engagement point
    ──────────────────────
        - A task point made private by an intracast privatizer.
            / The task point itself is either intracast, or extracast by way of a jointer.
        - It declares a way engagement.



    ━━━━━━━━━━━
     Way model
    ───────────
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - A waycast in compiled, executable form,
          as opposed to the initial, written form of its source code.
            - A representation of an aimed way of life.
            - A Waybreccian simulacrum.
        - It comprises a compiled directory of files, each originating either in the waycast
          or elsewhere subjoint of it.
        - It results from compiling the waycast.
            : re `compiling` see `^^ Compilation$`



    ━━━━━━
     Note
    ──────
        simulacral reference
            - Herein the default referent is the simulacrum (aka the way model), not the source code.
                : cf. `^^default referent` @ `^^ Simulacrum$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



                                                    \ Copyright © 2019-2021  Michael Allan.  Licence MIT.
